// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <getopt.h>
#include <signal.h>
#include <unistd.h>
#include <time.h>
#include <bpf/libbpf.h>
#include <bpf/bpf.h>
#include <sys/resource.h>
#include "cudamalloc_track.skel.h" // Generated by bpftool

// Define the event structure (must match the BPF side)
struct event {
    unsigned int pid;
    unsigned int tid;
    unsigned long long size;
    unsigned long long ts_ns;
};

static volatile sig_atomic_t exiting = 0;

static void sig_handler(int sig) {
    exiting = 1;
}

// Callback function for processing events from the ring buffer
static int handle_event(void *ctx, void *data, size_t data_sz) {
    const struct event *e = data;
    struct timespec ts;

    // Convert kernel timestamp to human-readable time
    clock_gettime(CLOCK_MONOTONIC, &ts); // Get current time to estimate offset if needed
                                         // A more accurate conversion might involve boot time.
    time_t T= time(NULL);
    struct tm tm = *localtime(&T);


    printf("%02d:%02d:%02d.%09lld | PID: %-7u | TID: %-7u | cudaMalloc(size: %llu)\n",
           tm.tm_hour, tm.tm_min, tm.tm_sec, e->ts_ns % 1000000000ULL,
           e->pid, e->tid, e->size);

    return 0; // Indicate success
}

// Helper to bump RLIMIT_MEMLOCK
static int bump_memlock_rlimit(void) {
    struct rlimit rlim_new = {
        .rlim_cur = RLIM_INFINITY,
        .rlim_max = RLIM_INFINITY,
    };
    if (setrlimit(RLIMIT_MEMLOCK, &rlim_new)) {
        fprintf(stderr, "Failed to increase RLIMIT_MEMLOCK limit! (%s)\n", strerror(errno));
        return -1;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct cudamalloc_track_bpf *skel = NULL;
    struct ring_buffer *rb = NULL;
    int err;
    const char *target_bin = NULL;
    const char *target_func = "cudaMalloc"; // Function to trace

    if (argc < 2) {
        fprintf(stderr, "Usage: %s <path_to_binary_or_library>\n", argv[0]);
        fprintf(stderr, "Example: %s /usr/local/cuda/lib64/libcudart.so.11.0\n", argv[0]);
        fprintf(stderr, "   OR    %s ./my_cuda_app\n", argv[0]);
        return 1;
    }
    target_bin = argv[1];

    // Set up signal handler for clean exit
    signal(SIGINT, sig_handler);
    signal(SIGTERM, sig_handler);

    // Initialize libbpf library internals
    // libbpf_set_print(LIBBPF_PRINT_LEVEL_WARN); // Print warnings or errors from libbpf

    // Bump memory lock limit
    if (bump_memlock_rlimit() < 0) {
        return 1;
    }

    // Open BPF application skeleton
    skel = cudamalloc_track_bpf__open();
    if (!skel) {
        fprintf(stderr, "Failed to open BPF skeleton\n");
        return 1;
    }

    // Load & verify BPF programs before attaching
    err = cudamalloc_track_bpf__load(skel);
    if (err) {
        fprintf(stderr, "Failed to load and verify BPF skeleton\n");
        goto cleanup;
    }

    // Attach the uprobe
    // Use libbpf's helper to attach a uprobe using function name
    // This requires libbpf to find the offset of the symbol within the binary/library.
    // It attaches globally (pid = -1).
    LIBBPF_OPTS(bpf_uprobe_opts, uprobe_opts, .func_name = target_func, .retprobe = false);
    skel->links.handle_cudaMalloc_entry = bpf_program__attach_uprobe_opts(
        skel->progs.handle_cudaMalloc_entry,
        -1, // Attach globally (all processes using this binary/library)
        target_bin,
        0, // Offset (0 means use func_name from opts)
        &uprobe_opts);

    if (!skel->links.handle_cudaMalloc_entry) {
        err = -errno; // libbpf usually sets errno
        fprintf(stderr, "Failed to attach uprobe to %s:%s (%d: %s)\n",
                target_bin, target_func, err, strerror(-err));
        goto cleanup;
    }

    printf("Successfully attached BPF program. Tracing %s calls in %s...\n", target_func, target_bin);
    printf("Press Ctrl+C to stop.\n");
    printf("--------------------------------------------------------------------------------\n");
    printf("%-25s | %-11s | %-11s | %s\n", "TIME", "PID", "TID", "EVENT");
    printf("--------------------------------------------------------------------------------\n");


    // Set up ring buffer polling
    rb = ring_buffer__new(bpf_map__fd(skel->maps.events), handle_event, NULL, NULL);
    if (!rb) {
        err = -1;
        fprintf(stderr, "Failed to create ring buffer\n");
        goto cleanup;
    }

    // Main event loop
    while (!exiting) {
        // Poll the ring buffer for events with a timeout (e.g., 100ms)
        err = ring_buffer__poll(rb, 100);
        if (err == -EINTR) {
            // Interrupted by signal, reset error and check exit flag
            err = 0;
            continue;
        }
        if (err < 0) {
            fprintf(stderr, "Error polling ring buffer: %s\n", strerror(-err));
            break; // Exit on polling error
        }
        // handle_event() was called for any events received
    }

cleanup:
    printf("\nDetaching and cleaning up...\n");
    ring_buffer__free(rb); // Also destroys the ring buffer manager
    cudamalloc_track_bpf__destroy(skel); // Destroys skeleton, detach links, unload programs, free maps

    return err < 0 ? -err : 0;
}